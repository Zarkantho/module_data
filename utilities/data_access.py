import yaml
import os
import json

from willitlink.base.graph import MultiGraph

# This file should be the way to interact with all external files used and generated by this
# project.
#
# XXX: A lot of these functions generate unneeded data and should go away.
#
# Current sources are (relative to the base directory passed into the functions below):
PROJECT_STRUCTURE_FILENAME = "modules.yaml" # human generated modules structure
WILLITLINK_DATA_DIRECTORY = "willitlink-data" # data generated by willitlink
PROCESSED_PROJECT_STRUCTURE_FILENAME = "modules_processed.yaml" # merged version of the two data sources above


def read_yaml_file(filename):
    return yaml.load(open(filename))

def write_yaml_file(filename, output_dict):
    with open(filename, 'w') as f:
        f.write(yaml.dump(output_dict, indent=4, default_flow_style=False))



def read_project_structure_file(project_data_directory):
    return read_yaml_file(os.path.join(project_data_directory, PROJECT_STRUCTURE_FILENAME))

# TODO: Actually preserve the ordering as I dump the YAML file.  See
# http://stackoverflow.com/questions/8651095/controlling-yaml-serialization-order-in-python
def write_project_structure_file(project_data_directory, project_structure):
    write_yaml_file(os.path.join(project_data_directory, PROJECT_STRUCTURE_FILENAME), project_structure)



def read_processed_project_structure_file(project_data_directory):
    return read_yaml_file(os.path.join(project_data_directory, PROCESSED_PROJECT_STRUCTURE_FILENAME))

# TODO: Actually preserve the ordering as I dump the YAML file.  See
# http://stackoverflow.com/questions/8651095/controlling-yaml-serialization-order-in-python
def write_processed_project_structure_file(project_data_directory, project_structure):
    write_yaml_file(os.path.join(project_data_directory, PROCESSED_PROJECT_STRUCTURE_FILENAME), project_structure)



def get_willitlink_data_directory(project_data_directory):
    return os.path.join(project_data_directory, WILLITLINK_DATA_DIRECTORY)

def load_willitlink_graph(project_data_directory):
    return MultiGraph(timers=False).load(get_willitlink_data_directory(project_data_directory))



def dump_module_files(project_directory, result_map):

    for system_name in result_map.keys():
        system_directory = os.path.join(project_directory, system_name)
        if not os.path.exists(system_directory):
            os.mkdir(system_directory)
        for module_object in result_map[system_name]['modules']:
            module_directory = os.path.join(system_directory, module_object['name'])
            if not os.path.exists(module_directory):
                os.mkdir(module_directory)
            module_file = open(os.path.join(module_directory, 'module.yaml'), 'w')
            module_file.write(yaml.dump(module_object, indent=4, default_flow_style=False))

    return result_map



def output_detailed_module_data(project_directory, project_data):
    for system_name in project_data.keys():
        modules_directory = os.path.join(project_directory, system_name)
        for module_object in project_data[system_name]['modules']:
            if os.path.isdir(os.path.join(modules_directory, module_object['name'])):
                # Put data about the interface
                f = open(os.path.join(modules_directory, module_object['name'], "interface.json"), 'w')
                f.truncate()
                f.write(json.dumps(module_object['interface'], indent=4))
                # Put data about the leaks
                f = open(os.path.join(modules_directory, module_object['name'], "leaks.json"), 'w')
                f.truncate()
                f.write(json.dumps(module_object['leaks'], indent=4))
                # Put data about the files_with_exec
                f = open(os.path.join(modules_directory, module_object['name'], "files_with_exec.json"), 'w')
                f.truncate()
                f.write(json.dumps(module_object['files_with_exec'], indent=4))

